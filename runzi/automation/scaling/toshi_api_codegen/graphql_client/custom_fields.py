# Generated by ariadne-codegen

from typing import Any, Dict, Optional, Union

from .base_operation import GraphQLField
from .custom_typing_fields import (
    AggregateInversionSolutionGraphQLField,
    AppendInversionSolutionTablesPayloadGraphQLField,
    AutomationTaskGraphQLField,
    AutomationTaskInterfaceGraphQLField,
    AutomationTaskUnionUnion,
    ChildTaskUnionUnion,
    CreateAggregateInversionSolutionPayloadGraphQLField,
    CreateAutomationTaskGraphQLField,
    CreateFileGraphQLField,
    CreateFileRelationGraphQLField,
    CreateGeneralTaskPayloadGraphQLField,
    CreateInversionSolutionNrmlPayloadGraphQLField,
    CreateInversionSolutionPayloadGraphQLField,
    CreateOpenquakeHazardConfigPayloadGraphQLField,
    CreateOpenquakeHazardSolutionPayloadGraphQLField,
    CreateOpenquakeHazardTaskGraphQLField,
    CreateRuptureGenerationTaskGraphQLField,
    CreateScaledInversionSolutionPayloadGraphQLField,
    CreateSmsFileGraphQLField,
    CreateStrongMotionStationPayloadGraphQLField,
    CreateTablePayloadGraphQLField,
    CreateTaskTaskRelationGraphQLField,
    CreateTimeDependentInversionSolutionPayloadGraphQLField,
    FileConnectionGraphQLField,
    FileEdgeGraphQLField,
    FileGraphQLField,
    FileInterfaceGraphQLField,
    FileRelationConnectionGraphQLField,
    FileRelationEdgeGraphQLField,
    FileRelationGraphQLField,
    FileUnionUnion,
    GeneralTaskGraphQLField,
    InversionSolutionGraphQLField,
    InversionSolutionInterfaceGraphQLField,
    InversionSolutionNrmlGraphQLField,
    InversionSolutionUnionUnion,
    KeyValueListPairGraphQLField,
    KeyValuePairGraphQLField,
    LabelledTableRelationGraphQLField,
    NodeFilterGraphQLField,
    NodeGraphQLField,
    ObjectIdentitiesConnectionGraphQLField,
    ObjectIdentitiesEdgeGraphQLField,
    ObjectIdentityGraphQLField,
    OpenquakeHazardConfigGraphQLField,
    OpenquakeHazardSolutionGraphQLField,
    OpenquakeHazardTaskGraphQLField,
    OpenquakeNrmlUnionUnion,
    PageInfoGraphQLField,
    PredecessorGraphQLField,
    PredecessorsInterfaceGraphQLField,
    PredecessorUnionUnion,
    RuptureGenerationTaskConnectionGraphQLField,
    RuptureGenerationTaskEdgeGraphQLField,
    RuptureGenerationTaskGraphQLField,
    ScaledInversionSolutionGraphQLField,
    SearchGraphQLField,
    SearchResultConnectionGraphQLField,
    SearchResultEdgeGraphQLField,
    SearchResultUnion,
    SmsFileGraphQLField,
    SourceSolutionUnionUnion,
    StrongMotionStationConnectionGraphQLField,
    StrongMotionStationEdgeGraphQLField,
    StrongMotionStationGraphQLField,
    TableGraphQLField,
    TaskTaskRelationConnectionGraphQLField,
    TaskTaskRelationEdgeGraphQLField,
    TaskTaskRelationGraphQLField,
    ThingGraphQLField,
    TimeDependentInversionSolutionGraphQLField,
    UpdateAutomationTaskGraphQLField,
    UpdateGeneralTaskPayloadGraphQLField,
    UpdateOpenquakeHazardTaskGraphQLField,
    UpdateRuptureGenerationTaskGraphQLField,
)


class AggregateInversionSolutionFields(GraphQLField):
    id: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("id")
    )
    file_name: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("file_name")
    )
    md_5_digest: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("md5_digest")
    )
    file_size: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("file_size")
    )
    file_url: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("file_url")
    )
    post_url: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("post_url")
    )

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    created: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("created")
    )

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    mfd_table_id: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("mfd_table_id")
    )
    hazard_table_id: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("hazard_table_id")
    )

    @classmethod
    def hazard_table(cls) -> "TableFields":
        return TableFields("hazard_table")

    @classmethod
    def mfd_table(cls) -> "TableFields":
        return TableFields("mfd_table")

    produced_by: "AutomationTaskUnionUnion" = AutomationTaskUnionUnion("produced_by")

    @classmethod
    def tables(cls) -> "LabelledTableRelationFields":
        return LabelledTableRelationFields("tables")

    @classmethod
    def common_rupture_set(cls) -> "FileFields":
        return FileFields("common_rupture_set")

    source_solutions: "SourceSolutionUnionUnion" = SourceSolutionUnionUnion(
        "source_solutions"
    )
    aggregation_fn: "AggregateInversionSolutionGraphQLField" = (
        AggregateInversionSolutionGraphQLField("aggregation_fn")
    )

    def fields(
        self,
        *subfields: Union[
            AggregateInversionSolutionGraphQLField,
            "AutomationTaskUnionUnion",
            "FileFields",
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "LabelledTableRelationFields",
            "PredecessorFields",
            "SourceSolutionUnionUnion",
            "TableFields",
        ]
    ) -> "AggregateInversionSolutionFields":
        """Subfields should come from the AggregateInversionSolutionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AggregateInversionSolutionFields":
        self._alias = alias
        return self


class AppendInversionSolutionTablesPayloadFields(GraphQLField):
    @classmethod
    def inversion_solution(cls) -> "InversionSolutionFields":
        return InversionSolutionFields("inversion_solution")

    ok: "AppendInversionSolutionTablesPayloadGraphQLField" = (
        AppendInversionSolutionTablesPayloadGraphQLField("ok")
    )
    client_mutation_id: "AppendInversionSolutionTablesPayloadGraphQLField" = (
        AppendInversionSolutionTablesPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            AppendInversionSolutionTablesPayloadGraphQLField, "InversionSolutionFields"
        ]
    ) -> "AppendInversionSolutionTablesPayloadFields":
        """Subfields should come from the AppendInversionSolutionTablesPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AppendInversionSolutionTablesPayloadFields":
        self._alias = alias
        return self


class AutomationTaskFields(GraphQLField):
    id: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("id")
    created: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("created")

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    result: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("result")
    state: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("state")
    duration: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("duration")

    @classmethod
    def arguments(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("arguments")

    @classmethod
    def environment(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("environment")

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    model_type: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("model_type")
    task_type: "AutomationTaskGraphQLField" = AutomationTaskGraphQLField("task_type")
    inversion_solution: "InversionSolutionUnionUnion" = InversionSolutionUnionUnion(
        "inversion_solution"
    )

    def fields(
        self,
        *subfields: Union[
            AutomationTaskGraphQLField,
            "FileRelationConnectionFields",
            "InversionSolutionUnionUnion",
            "KeyValuePairFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "AutomationTaskFields":
        """Subfields should come from the AutomationTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AutomationTaskFields":
        self._alias = alias
        return self


class AutomationTaskInterfaceInterface(GraphQLField):
    result: "AutomationTaskInterfaceGraphQLField" = AutomationTaskInterfaceGraphQLField(
        "result"
    )
    state: "AutomationTaskInterfaceGraphQLField" = AutomationTaskInterfaceGraphQLField(
        "state"
    )
    created: "AutomationTaskInterfaceGraphQLField" = (
        AutomationTaskInterfaceGraphQLField("created")
    )
    duration: "AutomationTaskInterfaceGraphQLField" = (
        AutomationTaskInterfaceGraphQLField("duration")
    )

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def arguments(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("arguments")

    @classmethod
    def environment(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("environment")

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    def fields(
        self,
        *subfields: Union[
            AutomationTaskInterfaceGraphQLField,
            "KeyValuePairFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "AutomationTaskInterfaceInterface":
        """Subfields should come from the AutomationTaskInterfaceInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AutomationTaskInterfaceInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "AutomationTaskInterfaceInterface":
        self._inline_fragments[type_name] = subfields
        return self


class CreateAggregateInversionSolutionPayloadFields(GraphQLField):
    @classmethod
    def solution(cls) -> "AggregateInversionSolutionFields":
        return AggregateInversionSolutionFields("solution")

    ok: "CreateAggregateInversionSolutionPayloadGraphQLField" = (
        CreateAggregateInversionSolutionPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateAggregateInversionSolutionPayloadGraphQLField" = (
        CreateAggregateInversionSolutionPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateAggregateInversionSolutionPayloadGraphQLField,
            "AggregateInversionSolutionFields",
        ]
    ) -> "CreateAggregateInversionSolutionPayloadFields":
        """Subfields should come from the CreateAggregateInversionSolutionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateAggregateInversionSolutionPayloadFields":
        self._alias = alias
        return self


class CreateAutomationTaskFields(GraphQLField):
    @classmethod
    def task_result(cls) -> "AutomationTaskFields":
        return AutomationTaskFields("task_result")

    def fields(
        self,
        *subfields: Union[CreateAutomationTaskGraphQLField, "AutomationTaskFields"]
    ) -> "CreateAutomationTaskFields":
        """Subfields should come from the CreateAutomationTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateAutomationTaskFields":
        self._alias = alias
        return self


class CreateFileFields(GraphQLField):
    ok: "CreateFileGraphQLField" = CreateFileGraphQLField("ok")

    @classmethod
    def file_result(cls) -> "FileFields":
        return FileFields("file_result")

    def fields(
        self, *subfields: Union[CreateFileGraphQLField, "FileFields"]
    ) -> "CreateFileFields":
        """Subfields should come from the CreateFileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateFileFields":
        self._alias = alias
        return self


class CreateFileRelationFields(GraphQLField):
    ok: "CreateFileRelationGraphQLField" = CreateFileRelationGraphQLField("ok")

    @classmethod
    def file_relation(cls) -> "FileRelationFields":
        return FileRelationFields("file_relation")

    def fields(
        self, *subfields: Union[CreateFileRelationGraphQLField, "FileRelationFields"]
    ) -> "CreateFileRelationFields":
        """Subfields should come from the CreateFileRelationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateFileRelationFields":
        self._alias = alias
        return self


class CreateGeneralTaskPayloadFields(GraphQLField):
    @classmethod
    def general_task(cls) -> "GeneralTaskFields":
        return GeneralTaskFields("general_task")

    client_mutation_id: "CreateGeneralTaskPayloadGraphQLField" = (
        CreateGeneralTaskPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[CreateGeneralTaskPayloadGraphQLField, "GeneralTaskFields"]
    ) -> "CreateGeneralTaskPayloadFields":
        """Subfields should come from the CreateGeneralTaskPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateGeneralTaskPayloadFields":
        self._alias = alias
        return self


class CreateInversionSolutionNrmlPayloadFields(GraphQLField):
    @classmethod
    def inversion_solution_nrml(cls) -> "InversionSolutionNrmlFields":
        return InversionSolutionNrmlFields("inversion_solution_nrml")

    ok: "CreateInversionSolutionNrmlPayloadGraphQLField" = (
        CreateInversionSolutionNrmlPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateInversionSolutionNrmlPayloadGraphQLField" = (
        CreateInversionSolutionNrmlPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateInversionSolutionNrmlPayloadGraphQLField,
            "InversionSolutionNrmlFields",
        ]
    ) -> "CreateInversionSolutionNrmlPayloadFields":
        """Subfields should come from the CreateInversionSolutionNrmlPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateInversionSolutionNrmlPayloadFields":
        self._alias = alias
        return self


class CreateInversionSolutionPayloadFields(GraphQLField):
    @classmethod
    def inversion_solution(cls) -> "InversionSolutionFields":
        return InversionSolutionFields("inversion_solution")

    ok: "CreateInversionSolutionPayloadGraphQLField" = (
        CreateInversionSolutionPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateInversionSolutionPayloadGraphQLField" = (
        CreateInversionSolutionPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateInversionSolutionPayloadGraphQLField, "InversionSolutionFields"
        ]
    ) -> "CreateInversionSolutionPayloadFields":
        """Subfields should come from the CreateInversionSolutionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateInversionSolutionPayloadFields":
        self._alias = alias
        return self


class CreateOpenquakeHazardConfigPayloadFields(GraphQLField):
    @classmethod
    def config(cls) -> "OpenquakeHazardConfigFields":
        return OpenquakeHazardConfigFields("config")

    ok: "CreateOpenquakeHazardConfigPayloadGraphQLField" = (
        CreateOpenquakeHazardConfigPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateOpenquakeHazardConfigPayloadGraphQLField" = (
        CreateOpenquakeHazardConfigPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateOpenquakeHazardConfigPayloadGraphQLField,
            "OpenquakeHazardConfigFields",
        ]
    ) -> "CreateOpenquakeHazardConfigPayloadFields":
        """Subfields should come from the CreateOpenquakeHazardConfigPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateOpenquakeHazardConfigPayloadFields":
        self._alias = alias
        return self


class CreateOpenquakeHazardSolutionPayloadFields(GraphQLField):
    @classmethod
    def openquake_hazard_solution(cls) -> "OpenquakeHazardSolutionFields":
        return OpenquakeHazardSolutionFields("openquake_hazard_solution")

    ok: "CreateOpenquakeHazardSolutionPayloadGraphQLField" = (
        CreateOpenquakeHazardSolutionPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateOpenquakeHazardSolutionPayloadGraphQLField" = (
        CreateOpenquakeHazardSolutionPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateOpenquakeHazardSolutionPayloadGraphQLField,
            "OpenquakeHazardSolutionFields",
        ]
    ) -> "CreateOpenquakeHazardSolutionPayloadFields":
        """Subfields should come from the CreateOpenquakeHazardSolutionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateOpenquakeHazardSolutionPayloadFields":
        self._alias = alias
        return self


class CreateOpenquakeHazardTaskFields(GraphQLField):
    ok: "CreateOpenquakeHazardTaskGraphQLField" = CreateOpenquakeHazardTaskGraphQLField(
        "ok"
    )

    @classmethod
    def openquake_hazard_task(cls) -> "OpenquakeHazardTaskFields":
        return OpenquakeHazardTaskFields("openquake_hazard_task")

    def fields(
        self,
        *subfields: Union[
            CreateOpenquakeHazardTaskGraphQLField, "OpenquakeHazardTaskFields"
        ]
    ) -> "CreateOpenquakeHazardTaskFields":
        """Subfields should come from the CreateOpenquakeHazardTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateOpenquakeHazardTaskFields":
        self._alias = alias
        return self


class CreateRuptureGenerationTaskFields(GraphQLField):
    @classmethod
    def task_result(cls) -> "RuptureGenerationTaskFields":
        return RuptureGenerationTaskFields("task_result")

    def fields(
        self,
        *subfields: Union[
            CreateRuptureGenerationTaskGraphQLField, "RuptureGenerationTaskFields"
        ]
    ) -> "CreateRuptureGenerationTaskFields":
        """Subfields should come from the CreateRuptureGenerationTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateRuptureGenerationTaskFields":
        self._alias = alias
        return self


class CreateScaledInversionSolutionPayloadFields(GraphQLField):
    @classmethod
    def solution(cls) -> "ScaledInversionSolutionFields":
        return ScaledInversionSolutionFields("solution")

    ok: "CreateScaledInversionSolutionPayloadGraphQLField" = (
        CreateScaledInversionSolutionPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateScaledInversionSolutionPayloadGraphQLField" = (
        CreateScaledInversionSolutionPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateScaledInversionSolutionPayloadGraphQLField,
            "ScaledInversionSolutionFields",
        ]
    ) -> "CreateScaledInversionSolutionPayloadFields":
        """Subfields should come from the CreateScaledInversionSolutionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateScaledInversionSolutionPayloadFields":
        self._alias = alias
        return self


class CreateSmsFileFields(GraphQLField):
    ok: "CreateSmsFileGraphQLField" = CreateSmsFileGraphQLField("ok")

    @classmethod
    def file_result(cls) -> "SmsFileFields":
        return SmsFileFields("file_result")

    def fields(
        self, *subfields: Union[CreateSmsFileGraphQLField, "SmsFileFields"]
    ) -> "CreateSmsFileFields":
        """Subfields should come from the CreateSmsFileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateSmsFileFields":
        self._alias = alias
        return self


class CreateStrongMotionStationPayloadFields(GraphQLField):
    @classmethod
    def strong_motion_station(cls) -> "StrongMotionStationFields":
        return StrongMotionStationFields("strong_motion_station")

    client_mutation_id: "CreateStrongMotionStationPayloadGraphQLField" = (
        CreateStrongMotionStationPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateStrongMotionStationPayloadGraphQLField, "StrongMotionStationFields"
        ]
    ) -> "CreateStrongMotionStationPayloadFields":
        """Subfields should come from the CreateStrongMotionStationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateStrongMotionStationPayloadFields":
        self._alias = alias
        return self


class CreateTablePayloadFields(GraphQLField):
    @classmethod
    def table(cls) -> "TableFields":
        return TableFields("table")

    client_mutation_id: "CreateTablePayloadGraphQLField" = (
        CreateTablePayloadGraphQLField("clientMutationId")
    )

    def fields(
        self, *subfields: Union[CreateTablePayloadGraphQLField, "TableFields"]
    ) -> "CreateTablePayloadFields":
        """Subfields should come from the CreateTablePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateTablePayloadFields":
        self._alias = alias
        return self


class CreateTaskTaskRelationFields(GraphQLField):
    ok: "CreateTaskTaskRelationGraphQLField" = CreateTaskTaskRelationGraphQLField("ok")

    @classmethod
    def thing_relation(cls) -> "TaskTaskRelationFields":
        return TaskTaskRelationFields("thing_relation")

    def fields(
        self,
        *subfields: Union[CreateTaskTaskRelationGraphQLField, "TaskTaskRelationFields"]
    ) -> "CreateTaskTaskRelationFields":
        """Subfields should come from the CreateTaskTaskRelationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateTaskTaskRelationFields":
        self._alias = alias
        return self


class CreateTimeDependentInversionSolutionPayloadFields(GraphQLField):
    @classmethod
    def solution(cls) -> "TimeDependentInversionSolutionFields":
        return TimeDependentInversionSolutionFields("solution")

    ok: "CreateTimeDependentInversionSolutionPayloadGraphQLField" = (
        CreateTimeDependentInversionSolutionPayloadGraphQLField("ok")
    )
    client_mutation_id: "CreateTimeDependentInversionSolutionPayloadGraphQLField" = (
        CreateTimeDependentInversionSolutionPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[
            CreateTimeDependentInversionSolutionPayloadGraphQLField,
            "TimeDependentInversionSolutionFields",
        ]
    ) -> "CreateTimeDependentInversionSolutionPayloadFields":
        """Subfields should come from the CreateTimeDependentInversionSolutionPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateTimeDependentInversionSolutionPayloadFields":
        self._alias = alias
        return self


class FileFields(GraphQLField):
    id: "FileGraphQLField" = FileGraphQLField("id")
    file_name: "FileGraphQLField" = FileGraphQLField("file_name")
    md_5_digest: "FileGraphQLField" = FileGraphQLField("md5_digest")
    file_size: "FileGraphQLField" = FileGraphQLField("file_size")
    file_url: "FileGraphQLField" = FileGraphQLField("file_url")
    post_url: "FileGraphQLField" = FileGraphQLField("post_url")

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    def fields(
        self,
        *subfields: Union[
            FileGraphQLField,
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "PredecessorFields",
        ]
    ) -> "FileFields":
        """Subfields should come from the FileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileFields":
        self._alias = alias
        return self


class FileConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "FileEdgeFields":
        return FileEdgeFields("edges")

    total_count: "FileConnectionGraphQLField" = FileConnectionGraphQLField(
        "total_count"
    )

    def fields(
        self,
        *subfields: Union[
            FileConnectionGraphQLField, "FileEdgeFields", "PageInfoFields"
        ]
    ) -> "FileConnectionFields":
        """Subfields should come from the FileConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileConnectionFields":
        self._alias = alias
        return self


class FileEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "FileFields":
        return FileFields("node")

    cursor: "FileEdgeGraphQLField" = FileEdgeGraphQLField("cursor")

    def fields(
        self, *subfields: Union[FileEdgeGraphQLField, "FileFields"]
    ) -> "FileEdgeFields":
        """Subfields should come from the FileEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileEdgeFields":
        self._alias = alias
        return self


class FileInterfaceInterface(GraphQLField):
    file_name: "FileInterfaceGraphQLField" = FileInterfaceGraphQLField("file_name")
    md_5_digest: "FileInterfaceGraphQLField" = FileInterfaceGraphQLField("md5_digest")
    file_size: "FileInterfaceGraphQLField" = FileInterfaceGraphQLField("file_size")
    file_url: "FileInterfaceGraphQLField" = FileInterfaceGraphQLField("file_url")
    post_url: "FileInterfaceGraphQLField" = FileInterfaceGraphQLField("post_url")

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            FileInterfaceGraphQLField,
            "FileRelationConnectionFields",
            "KeyValuePairFields",
        ]
    ) -> "FileInterfaceInterface":
        """Subfields should come from the FileInterfaceInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileInterfaceInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "FileInterfaceInterface":
        self._inline_fragments[type_name] = subfields
        return self


class FileRelationFields(GraphQLField):
    @classmethod
    def thing(cls) -> "ThingInterface":
        return ThingInterface("thing")

    file: "FileUnionUnion" = FileUnionUnion("file")
    role: "FileRelationGraphQLField" = FileRelationGraphQLField("role")
    thing_id: "FileRelationGraphQLField" = FileRelationGraphQLField("thing_id")
    file_id: "FileRelationGraphQLField" = FileRelationGraphQLField("file_id")

    def fields(
        self,
        *subfields: Union[FileRelationGraphQLField, "FileUnionUnion", "ThingInterface"]
    ) -> "FileRelationFields":
        """Subfields should come from the FileRelationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileRelationFields":
        self._alias = alias
        return self


class FileRelationConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "FileRelationEdgeFields":
        return FileRelationEdgeFields("edges")

    total_count: "FileRelationConnectionGraphQLField" = (
        FileRelationConnectionGraphQLField("total_count")
    )

    def fields(
        self,
        *subfields: Union[
            FileRelationConnectionGraphQLField,
            "FileRelationEdgeFields",
            "PageInfoFields",
        ]
    ) -> "FileRelationConnectionFields":
        """Subfields should come from the FileRelationConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileRelationConnectionFields":
        self._alias = alias
        return self


class FileRelationEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "FileRelationFields":
        return FileRelationFields("node")

    cursor: "FileRelationEdgeGraphQLField" = FileRelationEdgeGraphQLField("cursor")

    def fields(
        self, *subfields: Union[FileRelationEdgeGraphQLField, "FileRelationFields"]
    ) -> "FileRelationEdgeFields":
        """Subfields should come from the FileRelationEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FileRelationEdgeFields":
        self._alias = alias
        return self


class GeneralTaskFields(GraphQLField):
    id: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("id")
    created: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("created")

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    updated: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("updated")
    agent_name: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("agent_name")
    title: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("title")
    description: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("description")

    @classmethod
    def argument_lists(cls) -> "KeyValueListPairFields":
        return KeyValueListPairFields("argument_lists")

    swept_arguments: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField(
        "swept_arguments"
    )

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    notes: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("notes")
    subtask_count: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("subtask_count")
    subtask_type: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("subtask_type")
    model_type: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField("model_type")
    subtask_result: "GeneralTaskGraphQLField" = GeneralTaskGraphQLField(
        "subtask_result"
    )

    def fields(
        self,
        *subfields: Union[
            GeneralTaskGraphQLField,
            "FileRelationConnectionFields",
            "KeyValueListPairFields",
            "KeyValuePairFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "GeneralTaskFields":
        """Subfields should come from the GeneralTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GeneralTaskFields":
        self._alias = alias
        return self


class InversionSolutionFields(GraphQLField):
    id: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField("id")
    created: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField("created")

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    mfd_table_id: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "mfd_table_id"
    )
    hazard_table_id: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "hazard_table_id"
    )

    @classmethod
    def hazard_table(cls) -> "TableFields":
        return TableFields("hazard_table")

    @classmethod
    def mfd_table(cls) -> "TableFields":
        return TableFields("mfd_table")

    produced_by: "AutomationTaskUnionUnion" = AutomationTaskUnionUnion("produced_by")

    @classmethod
    def tables(cls) -> "LabelledTableRelationFields":
        return LabelledTableRelationFields("tables")

    file_name: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "file_name"
    )
    md_5_digest: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "md5_digest"
    )
    file_size: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "file_size"
    )
    file_url: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "file_url"
    )
    post_url: "InversionSolutionGraphQLField" = InversionSolutionGraphQLField(
        "post_url"
    )

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    def fields(
        self,
        *subfields: Union[
            InversionSolutionGraphQLField,
            "AutomationTaskUnionUnion",
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "LabelledTableRelationFields",
            "PredecessorFields",
            "TableFields",
        ]
    ) -> "InversionSolutionFields":
        """Subfields should come from the InversionSolutionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InversionSolutionFields":
        self._alias = alias
        return self


class InversionSolutionInterfaceInterface(GraphQLField):
    created: "InversionSolutionInterfaceGraphQLField" = (
        InversionSolutionInterfaceGraphQLField("created")
    )

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    mfd_table_id: "InversionSolutionInterfaceGraphQLField" = (
        InversionSolutionInterfaceGraphQLField("mfd_table_id")
    )
    hazard_table_id: "InversionSolutionInterfaceGraphQLField" = (
        InversionSolutionInterfaceGraphQLField("hazard_table_id")
    )

    @classmethod
    def hazard_table(cls) -> "TableFields":
        return TableFields("hazard_table")

    @classmethod
    def mfd_table(cls) -> "TableFields":
        return TableFields("mfd_table")

    produced_by: "AutomationTaskUnionUnion" = AutomationTaskUnionUnion("produced_by")

    @classmethod
    def tables(cls) -> "LabelledTableRelationFields":
        return LabelledTableRelationFields("tables")

    def fields(
        self,
        *subfields: Union[
            InversionSolutionInterfaceGraphQLField,
            "AutomationTaskUnionUnion",
            "KeyValuePairFields",
            "LabelledTableRelationFields",
            "TableFields",
        ]
    ) -> "InversionSolutionInterfaceInterface":
        """Subfields should come from the InversionSolutionInterfaceInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InversionSolutionInterfaceInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "InversionSolutionInterfaceInterface":
        self._inline_fragments[type_name] = subfields
        return self


class InversionSolutionNrmlFields(GraphQLField):
    id: "InversionSolutionNrmlGraphQLField" = InversionSolutionNrmlGraphQLField("id")
    file_name: "InversionSolutionNrmlGraphQLField" = InversionSolutionNrmlGraphQLField(
        "file_name"
    )
    md_5_digest: "InversionSolutionNrmlGraphQLField" = (
        InversionSolutionNrmlGraphQLField("md5_digest")
    )
    file_size: "InversionSolutionNrmlGraphQLField" = InversionSolutionNrmlGraphQLField(
        "file_size"
    )
    file_url: "InversionSolutionNrmlGraphQLField" = InversionSolutionNrmlGraphQLField(
        "file_url"
    )
    post_url: "InversionSolutionNrmlGraphQLField" = InversionSolutionNrmlGraphQLField(
        "post_url"
    )

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    created: "InversionSolutionNrmlGraphQLField" = InversionSolutionNrmlGraphQLField(
        "created"
    )
    source_solution: "SourceSolutionUnionUnion" = SourceSolutionUnionUnion(
        "source_solution"
    )

    def fields(
        self,
        *subfields: Union[
            InversionSolutionNrmlGraphQLField,
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "PredecessorFields",
            "SourceSolutionUnionUnion",
        ]
    ) -> "InversionSolutionNrmlFields":
        """Subfields should come from the InversionSolutionNrmlFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InversionSolutionNrmlFields":
        self._alias = alias
        return self


class KeyValueListPairFields(GraphQLField):
    k: "KeyValueListPairGraphQLField" = KeyValueListPairGraphQLField("k")
    v: "KeyValueListPairGraphQLField" = KeyValueListPairGraphQLField("v")

    def fields(
        self, *subfields: KeyValueListPairGraphQLField
    ) -> "KeyValueListPairFields":
        """Subfields should come from the KeyValueListPairFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KeyValueListPairFields":
        self._alias = alias
        return self


class KeyValuePairFields(GraphQLField):
    k: "KeyValuePairGraphQLField" = KeyValuePairGraphQLField("k")
    v: "KeyValuePairGraphQLField" = KeyValuePairGraphQLField("v")

    def fields(self, *subfields: KeyValuePairGraphQLField) -> "KeyValuePairFields":
        """Subfields should come from the KeyValuePairFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "KeyValuePairFields":
        self._alias = alias
        return self


class LabelledTableRelationFields(GraphQLField):
    identity: "LabelledTableRelationGraphQLField" = LabelledTableRelationGraphQLField(
        "identity"
    )
    created: "LabelledTableRelationGraphQLField" = LabelledTableRelationGraphQLField(
        "created"
    )
    produced_by_id: "LabelledTableRelationGraphQLField" = (
        LabelledTableRelationGraphQLField("produced_by_id")
    )
    label: "LabelledTableRelationGraphQLField" = LabelledTableRelationGraphQLField(
        "label"
    )
    table_id: "LabelledTableRelationGraphQLField" = LabelledTableRelationGraphQLField(
        "table_id"
    )

    @classmethod
    def table(cls) -> "TableFields":
        return TableFields("table")

    table_type: "LabelledTableRelationGraphQLField" = LabelledTableRelationGraphQLField(
        "table_type"
    )

    @classmethod
    def dimensions(cls) -> "KeyValueListPairFields":
        return KeyValueListPairFields("dimensions")

    def fields(
        self,
        *subfields: Union[
            LabelledTableRelationGraphQLField, "KeyValueListPairFields", "TableFields"
        ]
    ) -> "LabelledTableRelationFields":
        """Subfields should come from the LabelledTableRelationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LabelledTableRelationFields":
        self._alias = alias
        return self


class NodeInterface(GraphQLField):
    id: "NodeGraphQLField" = NodeGraphQLField("id")

    def fields(self, *subfields: NodeGraphQLField) -> "NodeInterface":
        """Subfields should come from the NodeInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "NodeInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NodeFilterFields(GraphQLField):
    ok: "NodeFilterGraphQLField" = NodeFilterGraphQLField("ok")

    @classmethod
    def result(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "SearchResultConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SearchResultConnectionFields("result", arguments=cleared_arguments)

    def fields(
        self, *subfields: Union[NodeFilterGraphQLField, "SearchResultConnectionFields"]
    ) -> "NodeFilterFields":
        """Subfields should come from the NodeFilterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeFilterFields":
        self._alias = alias
        return self


class ObjectIdentitiesConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "ObjectIdentitiesEdgeFields":
        return ObjectIdentitiesEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            ObjectIdentitiesConnectionGraphQLField,
            "ObjectIdentitiesEdgeFields",
            "PageInfoFields",
        ]
    ) -> "ObjectIdentitiesConnectionFields":
        """Subfields should come from the ObjectIdentitiesConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ObjectIdentitiesConnectionFields":
        self._alias = alias
        return self


class ObjectIdentitiesEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "ObjectIdentityFields":
        return ObjectIdentityFields("node")

    cursor: "ObjectIdentitiesEdgeGraphQLField" = ObjectIdentitiesEdgeGraphQLField(
        "cursor"
    )

    def fields(
        self,
        *subfields: Union[ObjectIdentitiesEdgeGraphQLField, "ObjectIdentityFields"]
    ) -> "ObjectIdentitiesEdgeFields":
        """Subfields should come from the ObjectIdentitiesEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ObjectIdentitiesEdgeFields":
        self._alias = alias
        return self


class ObjectIdentityFields(GraphQLField):
    id: "ObjectIdentityGraphQLField" = ObjectIdentityGraphQLField("id")
    object_type: "ObjectIdentityGraphQLField" = ObjectIdentityGraphQLField(
        "object_type"
    )
    object_id: "ObjectIdentityGraphQLField" = ObjectIdentityGraphQLField("object_id")
    clazz_name: "ObjectIdentityGraphQLField" = ObjectIdentityGraphQLField("clazz_name")
    node_id: "ObjectIdentityGraphQLField" = ObjectIdentityGraphQLField("node_id")

    def fields(self, *subfields: ObjectIdentityGraphQLField) -> "ObjectIdentityFields":
        """Subfields should come from the ObjectIdentityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ObjectIdentityFields":
        self._alias = alias
        return self


class OpenquakeHazardConfigFields(GraphQLField):
    id: "OpenquakeHazardConfigGraphQLField" = OpenquakeHazardConfigGraphQLField("id")
    created: "OpenquakeHazardConfigGraphQLField" = OpenquakeHazardConfigGraphQLField(
        "created"
    )

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    source_models: "OpenquakeNrmlUnionUnion" = OpenquakeNrmlUnionUnion("source_models")

    @classmethod
    def template_archive(cls) -> "FileFields":
        return FileFields("template_archive")

    def fields(
        self,
        *subfields: Union[
            OpenquakeHazardConfigGraphQLField,
            "FileFields",
            "FileRelationConnectionFields",
            "OpenquakeNrmlUnionUnion",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "OpenquakeHazardConfigFields":
        """Subfields should come from the OpenquakeHazardConfigFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OpenquakeHazardConfigFields":
        self._alias = alias
        return self


class OpenquakeHazardSolutionFields(GraphQLField):
    id: "OpenquakeHazardSolutionGraphQLField" = OpenquakeHazardSolutionGraphQLField(
        "id"
    )
    created: "OpenquakeHazardSolutionGraphQLField" = (
        OpenquakeHazardSolutionGraphQLField("created")
    )

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    @classmethod
    def csv_archive(cls) -> "FileFields":
        return FileFields("csv_archive")

    @classmethod
    def hdf_5_archive(cls) -> "FileFields":
        return FileFields("hdf_5_archive")

    @classmethod
    def task_args(cls) -> "FileFields":
        return FileFields("task_args")

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def produced_by(cls) -> "OpenquakeHazardTaskFields":
        return OpenquakeHazardTaskFields("produced_by")

    @classmethod
    def config(cls) -> "OpenquakeHazardConfigFields":
        return OpenquakeHazardConfigFields("config")

    @classmethod
    def modified_config(cls) -> "FileFields":
        return FileFields("modified_config")

    def fields(
        self,
        *subfields: Union[
            OpenquakeHazardSolutionGraphQLField,
            "FileFields",
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "OpenquakeHazardConfigFields",
            "OpenquakeHazardTaskFields",
            "PredecessorFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "OpenquakeHazardSolutionFields":
        """Subfields should come from the OpenquakeHazardSolutionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OpenquakeHazardSolutionFields":
        self._alias = alias
        return self


class OpenquakeHazardTaskFields(GraphQLField):
    id: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField("id")
    created: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "created"
    )

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    result: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "result"
    )
    state: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField("state")
    duration: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "duration"
    )

    @classmethod
    def arguments(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("arguments")

    @classmethod
    def environment(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("environment")

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    @classmethod
    def config(cls) -> "OpenquakeHazardConfigFields":
        return OpenquakeHazardConfigFields("config")

    @classmethod
    def hazard_solution(cls) -> "OpenquakeHazardSolutionFields":
        return OpenquakeHazardSolutionFields("hazard_solution")

    model_type: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "model_type"
    )
    task_type: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "task_type"
    )
    executor: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "executor"
    )
    srm_logic_tree: "OpenquakeHazardTaskGraphQLField" = OpenquakeHazardTaskGraphQLField(
        "srm_logic_tree"
    )
    gmcm_logic_tree: "OpenquakeHazardTaskGraphQLField" = (
        OpenquakeHazardTaskGraphQLField("gmcm_logic_tree")
    )
    openquake_config: "OpenquakeHazardTaskGraphQLField" = (
        OpenquakeHazardTaskGraphQLField("openquake_config")
    )

    def fields(
        self,
        *subfields: Union[
            OpenquakeHazardTaskGraphQLField,
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "OpenquakeHazardConfigFields",
            "OpenquakeHazardSolutionFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "OpenquakeHazardTaskFields":
        """Subfields should come from the OpenquakeHazardTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "OpenquakeHazardTaskFields":
        self._alias = alias
        return self


class PageInfoFields(GraphQLField):
    has_next_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasNextPage")
    has_previous_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasPreviousPage")
    start_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("startCursor")
    end_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("endCursor")

    def fields(self, *subfields: PageInfoGraphQLField) -> "PageInfoFields":
        """Subfields should come from the PageInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageInfoFields":
        self._alias = alias
        return self


class PredecessorFields(GraphQLField):
    id: "PredecessorGraphQLField" = PredecessorGraphQLField("id")
    typename: "PredecessorGraphQLField" = PredecessorGraphQLField("typename")
    depth: "PredecessorGraphQLField" = PredecessorGraphQLField("depth")
    relationship: "PredecessorGraphQLField" = PredecessorGraphQLField("relationship")
    node: "PredecessorUnionUnion" = PredecessorUnionUnion("node")

    def fields(
        self, *subfields: Union[PredecessorGraphQLField, "PredecessorUnionUnion"]
    ) -> "PredecessorFields":
        """Subfields should come from the PredecessorFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PredecessorFields":
        self._alias = alias
        return self


class PredecessorsInterfaceInterface(GraphQLField):
    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    def fields(
        self, *subfields: Union[PredecessorsInterfaceGraphQLField, "PredecessorFields"]
    ) -> "PredecessorsInterfaceInterface":
        """Subfields should come from the PredecessorsInterfaceInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PredecessorsInterfaceInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "PredecessorsInterfaceInterface":
        self._inline_fragments[type_name] = subfields
        return self


class RuptureGenerationTaskFields(GraphQLField):
    id: "RuptureGenerationTaskGraphQLField" = RuptureGenerationTaskGraphQLField("id")
    created: "RuptureGenerationTaskGraphQLField" = RuptureGenerationTaskGraphQLField(
        "created"
    )

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    result: "RuptureGenerationTaskGraphQLField" = RuptureGenerationTaskGraphQLField(
        "result"
    )
    state: "RuptureGenerationTaskGraphQLField" = RuptureGenerationTaskGraphQLField(
        "state"
    )
    duration: "RuptureGenerationTaskGraphQLField" = RuptureGenerationTaskGraphQLField(
        "duration"
    )

    @classmethod
    def arguments(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("arguments")

    @classmethod
    def environment(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("environment")

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    def fields(
        self,
        *subfields: Union[
            RuptureGenerationTaskGraphQLField,
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "RuptureGenerationTaskFields":
        """Subfields should come from the RuptureGenerationTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RuptureGenerationTaskFields":
        self._alias = alias
        return self


class RuptureGenerationTaskConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "RuptureGenerationTaskEdgeFields":
        return RuptureGenerationTaskEdgeFields("edges")

    total_count: "RuptureGenerationTaskConnectionGraphQLField" = (
        RuptureGenerationTaskConnectionGraphQLField("total_count")
    )

    def fields(
        self,
        *subfields: Union[
            RuptureGenerationTaskConnectionGraphQLField,
            "PageInfoFields",
            "RuptureGenerationTaskEdgeFields",
        ]
    ) -> "RuptureGenerationTaskConnectionFields":
        """Subfields should come from the RuptureGenerationTaskConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RuptureGenerationTaskConnectionFields":
        self._alias = alias
        return self


class RuptureGenerationTaskEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "RuptureGenerationTaskFields":
        return RuptureGenerationTaskFields("node")

    cursor: "RuptureGenerationTaskEdgeGraphQLField" = (
        RuptureGenerationTaskEdgeGraphQLField("cursor")
    )

    def fields(
        self,
        *subfields: Union[
            RuptureGenerationTaskEdgeGraphQLField, "RuptureGenerationTaskFields"
        ]
    ) -> "RuptureGenerationTaskEdgeFields":
        """Subfields should come from the RuptureGenerationTaskEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RuptureGenerationTaskEdgeFields":
        self._alias = alias
        return self


class ScaledInversionSolutionFields(GraphQLField):
    id: "ScaledInversionSolutionGraphQLField" = ScaledInversionSolutionGraphQLField(
        "id"
    )
    file_name: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("file_name")
    )
    md_5_digest: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("md5_digest")
    )
    file_size: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("file_size")
    )
    file_url: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("file_url")
    )
    post_url: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("post_url")
    )

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    created: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("created")
    )

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    mfd_table_id: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("mfd_table_id")
    )
    hazard_table_id: "ScaledInversionSolutionGraphQLField" = (
        ScaledInversionSolutionGraphQLField("hazard_table_id")
    )

    @classmethod
    def hazard_table(cls) -> "TableFields":
        return TableFields("hazard_table")

    @classmethod
    def mfd_table(cls) -> "TableFields":
        return TableFields("mfd_table")

    produced_by: "AutomationTaskUnionUnion" = AutomationTaskUnionUnion("produced_by")

    @classmethod
    def tables(cls) -> "LabelledTableRelationFields":
        return LabelledTableRelationFields("tables")

    source_solution: "SourceSolutionUnionUnion" = SourceSolutionUnionUnion(
        "source_solution"
    )

    def fields(
        self,
        *subfields: Union[
            ScaledInversionSolutionGraphQLField,
            "AutomationTaskUnionUnion",
            "FileRelationConnectionFields",
            "KeyValuePairFields",
            "LabelledTableRelationFields",
            "PredecessorFields",
            "SourceSolutionUnionUnion",
            "TableFields",
        ]
    ) -> "ScaledInversionSolutionFields":
        """Subfields should come from the ScaledInversionSolutionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ScaledInversionSolutionFields":
        self._alias = alias
        return self


class SearchFields(GraphQLField):
    ok: "SearchGraphQLField" = SearchGraphQLField("ok")

    @classmethod
    def search_result(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "SearchResultConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SearchResultConnectionFields(
            "search_result", arguments=cleared_arguments
        )

    def fields(
        self, *subfields: Union[SearchGraphQLField, "SearchResultConnectionFields"]
    ) -> "SearchFields":
        """Subfields should come from the SearchFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchFields":
        self._alias = alias
        return self


class SearchResultConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "SearchResultEdgeFields":
        return SearchResultEdgeFields("edges")

    total_count: "SearchResultConnectionGraphQLField" = (
        SearchResultConnectionGraphQLField("total_count")
    )

    def fields(
        self,
        *subfields: Union[
            SearchResultConnectionGraphQLField,
            "PageInfoFields",
            "SearchResultEdgeFields",
        ]
    ) -> "SearchResultConnectionFields":
        """Subfields should come from the SearchResultConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchResultConnectionFields":
        self._alias = alias
        return self


class SearchResultEdgeFields(GraphQLField):
    node: "SearchResultUnion" = SearchResultUnion("node")
    cursor: "SearchResultEdgeGraphQLField" = SearchResultEdgeGraphQLField("cursor")

    def fields(
        self, *subfields: Union[SearchResultEdgeGraphQLField, "SearchResultUnion"]
    ) -> "SearchResultEdgeFields":
        """Subfields should come from the SearchResultEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SearchResultEdgeFields":
        self._alias = alias
        return self


class SmsFileFields(GraphQLField):
    id: "SmsFileGraphQLField" = SmsFileGraphQLField("id")
    file_name: "SmsFileGraphQLField" = SmsFileGraphQLField("file_name")
    md_5_digest: "SmsFileGraphQLField" = SmsFileGraphQLField("md5_digest")
    file_size: "SmsFileGraphQLField" = SmsFileGraphQLField("file_size")
    file_url: "SmsFileGraphQLField" = SmsFileGraphQLField("file_url")
    post_url: "SmsFileGraphQLField" = SmsFileGraphQLField("post_url")

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    file_type: "SmsFileGraphQLField" = SmsFileGraphQLField("file_type")

    def fields(
        self,
        *subfields: Union[
            SmsFileGraphQLField, "FileRelationConnectionFields", "KeyValuePairFields"
        ]
    ) -> "SmsFileFields":
        """Subfields should come from the SmsFileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SmsFileFields":
        self._alias = alias
        return self


class StrongMotionStationFields(GraphQLField):
    id: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField("id")
    created: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "created"
    )

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    updated: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "updated"
    )
    site_code: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "site_code"
    )
    site_class: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "site_class"
    )
    site_class_basis: "StrongMotionStationGraphQLField" = (
        StrongMotionStationGraphQLField("site_class_basis")
    )
    vs_30_mean: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "Vs30_mean"
    )
    vs_30_std_dev: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "Vs30_std_dev"
    )
    bedrock_encountered: "StrongMotionStationGraphQLField" = (
        StrongMotionStationGraphQLField("bedrock_encountered")
    )
    liquefiable: "StrongMotionStationGraphQLField" = StrongMotionStationGraphQLField(
        "liquefiable"
    )
    soft_clay_or_peat: "StrongMotionStationGraphQLField" = (
        StrongMotionStationGraphQLField("soft_clay_or_peat")
    )

    def fields(
        self,
        *subfields: Union[
            StrongMotionStationGraphQLField,
            "FileRelationConnectionFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "StrongMotionStationFields":
        """Subfields should come from the StrongMotionStationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StrongMotionStationFields":
        self._alias = alias
        return self


class StrongMotionStationConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "StrongMotionStationEdgeFields":
        return StrongMotionStationEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            StrongMotionStationConnectionGraphQLField,
            "PageInfoFields",
            "StrongMotionStationEdgeFields",
        ]
    ) -> "StrongMotionStationConnectionFields":
        """Subfields should come from the StrongMotionStationConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StrongMotionStationConnectionFields":
        self._alias = alias
        return self


class StrongMotionStationEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "StrongMotionStationFields":
        return StrongMotionStationFields("node")

    cursor: "StrongMotionStationEdgeGraphQLField" = StrongMotionStationEdgeGraphQLField(
        "cursor"
    )

    def fields(
        self,
        *subfields: Union[
            StrongMotionStationEdgeGraphQLField, "StrongMotionStationFields"
        ]
    ) -> "StrongMotionStationEdgeFields":
        """Subfields should come from the StrongMotionStationEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StrongMotionStationEdgeFields":
        self._alias = alias
        return self


class TableFields(GraphQLField):
    id: "TableGraphQLField" = TableGraphQLField("id")
    name: "TableGraphQLField" = TableGraphQLField("name")
    object_id: "TableGraphQLField" = TableGraphQLField("object_id")
    created: "TableGraphQLField" = TableGraphQLField("created")
    column_headers: "TableGraphQLField" = TableGraphQLField("column_headers")
    column_types: "TableGraphQLField" = TableGraphQLField("column_types")
    rows: "TableGraphQLField" = TableGraphQLField("rows")

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    table_type: "TableGraphQLField" = TableGraphQLField("table_type")

    @classmethod
    def dimensions(cls) -> "KeyValueListPairFields":
        return KeyValueListPairFields("dimensions")

    def fields(
        self,
        *subfields: Union[
            TableGraphQLField, "KeyValueListPairFields", "KeyValuePairFields"
        ]
    ) -> "TableFields":
        """Subfields should come from the TableFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TableFields":
        self._alias = alias
        return self


class TaskTaskRelationFields(GraphQLField):
    @classmethod
    def parent(cls) -> "GeneralTaskFields":
        return GeneralTaskFields("parent")

    child: "ChildTaskUnionUnion" = ChildTaskUnionUnion("child")
    parent_id: "TaskTaskRelationGraphQLField" = TaskTaskRelationGraphQLField(
        "parent_id"
    )
    child_id: "TaskTaskRelationGraphQLField" = TaskTaskRelationGraphQLField("child_id")

    def fields(
        self,
        *subfields: Union[
            TaskTaskRelationGraphQLField, "ChildTaskUnionUnion", "GeneralTaskFields"
        ]
    ) -> "TaskTaskRelationFields":
        """Subfields should come from the TaskTaskRelationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TaskTaskRelationFields":
        self._alias = alias
        return self


class TaskTaskRelationConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "TaskTaskRelationEdgeFields":
        return TaskTaskRelationEdgeFields("edges")

    total_count: "TaskTaskRelationConnectionGraphQLField" = (
        TaskTaskRelationConnectionGraphQLField("total_count")
    )

    def fields(
        self,
        *subfields: Union[
            TaskTaskRelationConnectionGraphQLField,
            "PageInfoFields",
            "TaskTaskRelationEdgeFields",
        ]
    ) -> "TaskTaskRelationConnectionFields":
        """Subfields should come from the TaskTaskRelationConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TaskTaskRelationConnectionFields":
        self._alias = alias
        return self


class TaskTaskRelationEdgeFields(GraphQLField):
    @classmethod
    def node(cls) -> "TaskTaskRelationFields":
        return TaskTaskRelationFields("node")

    cursor: "TaskTaskRelationEdgeGraphQLField" = TaskTaskRelationEdgeGraphQLField(
        "cursor"
    )

    def fields(
        self,
        *subfields: Union[TaskTaskRelationEdgeGraphQLField, "TaskTaskRelationFields"]
    ) -> "TaskTaskRelationEdgeFields":
        """Subfields should come from the TaskTaskRelationEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TaskTaskRelationEdgeFields":
        self._alias = alias
        return self


class ThingInterface(GraphQLField):
    created: "ThingGraphQLField" = ThingGraphQLField("created")

    @classmethod
    def files(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("files", arguments=cleared_arguments)

    @classmethod
    def parents(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("parents", arguments=cleared_arguments)

    @classmethod
    def children(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "TaskTaskRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TaskTaskRelationConnectionFields("children", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            ThingGraphQLField,
            "FileRelationConnectionFields",
            "TaskTaskRelationConnectionFields",
        ]
    ) -> "ThingInterface":
        """Subfields should come from the ThingInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ThingInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "ThingInterface":
        self._inline_fragments[type_name] = subfields
        return self


class TimeDependentInversionSolutionFields(GraphQLField):
    id: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("id")
    )
    file_name: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("file_name")
    )
    md_5_digest: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("md5_digest")
    )
    file_size: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("file_size")
    )
    file_url: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("file_url")
    )
    post_url: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("post_url")
    )

    @classmethod
    def meta(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("meta")

    @classmethod
    def relations(
        cls,
        *,
        before: Optional[str] = None,
        after: Optional[str] = None,
        first: Optional[int] = None,
        last: Optional[int] = None
    ) -> "FileRelationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "before": {"type": "String", "value": before},
            "after": {"type": "String", "value": after},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return FileRelationConnectionFields("relations", arguments=cleared_arguments)

    @classmethod
    def predecessors(cls) -> "PredecessorFields":
        return PredecessorFields("predecessors")

    created: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("created")
    )

    @classmethod
    def metrics(cls) -> "KeyValuePairFields":
        return KeyValuePairFields("metrics")

    mfd_table_id: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("mfd_table_id")
    )
    hazard_table_id: "TimeDependentInversionSolutionGraphQLField" = (
        TimeDependentInversionSolutionGraphQLField("hazard_table_id")
    )

    @classmethod
    def hazard_table(cls) -> "TableFields":
        return TableFields("hazard_table")

    @classmethod
    def mfd_table(cls) -> "TableFields":
        return TableFields("mfd_table")

    produced_by: "AutomationTaskUnionUnion" = AutomationTaskUnionUnion("produced_by")

    @classmethod
    def tables(cls) -> "LabelledTableRelationFields":
        return LabelledTableRelationFields("tables")

    @classmethod
    def source_solution(cls) -> "InversionSolutionFields":
        return InversionSolutionFields("source_solution")

    def fields(
        self,
        *subfields: Union[
            TimeDependentInversionSolutionGraphQLField,
            "AutomationTaskUnionUnion",
            "FileRelationConnectionFields",
            "InversionSolutionFields",
            "KeyValuePairFields",
            "LabelledTableRelationFields",
            "PredecessorFields",
            "TableFields",
        ]
    ) -> "TimeDependentInversionSolutionFields":
        """Subfields should come from the TimeDependentInversionSolutionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TimeDependentInversionSolutionFields":
        self._alias = alias
        return self


class UpdateAutomationTaskFields(GraphQLField):
    @classmethod
    def task_result(cls) -> "AutomationTaskFields":
        return AutomationTaskFields("task_result")

    def fields(
        self,
        *subfields: Union[UpdateAutomationTaskGraphQLField, "AutomationTaskFields"]
    ) -> "UpdateAutomationTaskFields":
        """Subfields should come from the UpdateAutomationTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UpdateAutomationTaskFields":
        self._alias = alias
        return self


class UpdateGeneralTaskPayloadFields(GraphQLField):
    @classmethod
    def general_task(cls) -> "GeneralTaskFields":
        return GeneralTaskFields("general_task")

    ok: "UpdateGeneralTaskPayloadGraphQLField" = UpdateGeneralTaskPayloadGraphQLField(
        "ok"
    )
    client_mutation_id: "UpdateGeneralTaskPayloadGraphQLField" = (
        UpdateGeneralTaskPayloadGraphQLField("clientMutationId")
    )

    def fields(
        self,
        *subfields: Union[UpdateGeneralTaskPayloadGraphQLField, "GeneralTaskFields"]
    ) -> "UpdateGeneralTaskPayloadFields":
        """Subfields should come from the UpdateGeneralTaskPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UpdateGeneralTaskPayloadFields":
        self._alias = alias
        return self


class UpdateOpenquakeHazardTaskFields(GraphQLField):
    ok: "UpdateOpenquakeHazardTaskGraphQLField" = UpdateOpenquakeHazardTaskGraphQLField(
        "ok"
    )

    @classmethod
    def openquake_hazard_task(cls) -> "OpenquakeHazardTaskFields":
        return OpenquakeHazardTaskFields("openquake_hazard_task")

    def fields(
        self,
        *subfields: Union[
            UpdateOpenquakeHazardTaskGraphQLField, "OpenquakeHazardTaskFields"
        ]
    ) -> "UpdateOpenquakeHazardTaskFields":
        """Subfields should come from the UpdateOpenquakeHazardTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UpdateOpenquakeHazardTaskFields":
        self._alias = alias
        return self


class UpdateRuptureGenerationTaskFields(GraphQLField):
    @classmethod
    def task_result(cls) -> "RuptureGenerationTaskFields":
        return RuptureGenerationTaskFields("task_result")

    def fields(
        self,
        *subfields: Union[
            UpdateRuptureGenerationTaskGraphQLField, "RuptureGenerationTaskFields"
        ]
    ) -> "UpdateRuptureGenerationTaskFields":
        """Subfields should come from the UpdateRuptureGenerationTaskFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UpdateRuptureGenerationTaskFields":
        self._alias = alias
        return self
